没有变化,不需要设计模式, 没有变化,不需要考虑紧耦合.
找到变化的部分，和不变化的部分. 
没有不变的对象，也没有全都变的系统.

一. 抽象工厂

简单描述:
一系列相互依赖的对象, 往往存在更多系列对象的创建工作.
(不是一系列的对象，不需要抽象工厂，简单工厂足够)

Gof: 
提供一个接口，让该接口负责创建一系列"相关或者相互依赖的对象", 无需指定他们具体的类.

要点:
1. 如果没有对"多系列对象构建"的需求变化, 仅仅是"需要哪些对象"经常发生改变不能使用该模式, 简单的静态工厂就可以.
对象的变化: 目前只有"道路、丛林",下次增加"建筑".
多系列对象构建："道路、丛林、建筑" 构建的变化, 对象相对稳定.

2. "系列对象"指的是这些对象之间有相互依赖、或作用的关系, 例如游戏开发场景中的"道路"与"房屋"的依赖,"道路"与"地道"的依赖.

3. 主要在于应对"新系列"的需求变动。其缺点在于难以应对"新对象"的需求变动.

4. 可以和 Factory Methond 模式共同组合来应对"对象创建"的需求变化.

二. 工厂模式

简单描述：某个对象创建的工作; 由于需求的变化，这个对象的具体实现经常面临着剧烈的变化, 但是它却拥有比较稳定的接口.
(如果接口也不稳定就不要使用该模式, 比如: 加油站和汽车, 汽车经常对象会经常变化，但如果和加油的接口也要变，还怎么加油)
从而保持系统中"其他依赖该对象的对象"不随着需求改变而改变

Gof：
定义一个用于创建对像的接口, 让子类决定实例化哪个类。工厂模式使一个类的实例化延迟到子类.

要点：
工厂模式解决"单个对象"的需求变化, 抽象工厂解决"系列对象"的需求变化, Builder 模式解决"对象部分"的需求变化.


三. 观察者模式

动机: 在软件构建过程中, 我们需要为某些对象建立一种“通知依赖关系”,一个对象(目标对象)的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。
如果这样的依赖关系过于紧密，将使软件不能很好的抵御变化。

Gof: 定义对象间的一种一对多的依赖关系, 以便当一个对象的状态发生改变时，所有依赖于他的对象都得到通知并自动更新.

要点:
1. Observer 模式使得我们可以独立的改变目标与观察者, 从而使二者依赖关系达到松耦合.
2. 目标发送通知时, 无需指定观察者, 通知(可以携带通知信息作为参数)会自动传播. 观察着自己决定是否需要订阅通知, 
目标对象对此一无所知.
3. C# 中, 委托充当了抽象的Observer接口, 而提供事件的对象充当了目标对象.

四. 代理模式

代理模式定义：
为其他对象提供一种代理以控制对这个对象的访问。代理对象起到中介作用，可去掉功能服务或增加额外的服务。

远程代理：为不同地理的对象提供局域网代表对象。
虚拟代理：根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建。
保护代理：保护对一个对象的访问权限
智能引用代理：提供对目标对象额外服务

